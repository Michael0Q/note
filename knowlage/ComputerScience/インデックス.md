# データベースのインデックス

## 1. はじめに：インデックスとは？

データベースにおける**インデックス（Index）**とは、テーブルからデータを高速に検索するための「索引」です。分厚い技術書の巻末にある索引を思い浮かべてみてください。特定のキーワードがどのページにあるかを知りたいとき、最初から最後までページをめくるのではなく、まず索引を引くでしょう。索引にはキーワードと対応するページ番号が整理されているため、目的の情報を素早く見つけることができます。

データベースのインデックスもこれと全く同じ役割を果たします。特定のカラム（列）の値をキーとして、その値を持つデータがテーブル内のどこに保存されているかという位置情報（ポインタ）を保持するデータ構造です。インデックスがない場合、データベースはテーブルの全データを先頭から順にスキャン（フルテーブルスキャン）する必要があり、データ量が増えるほど検索に時間がかかります。インデックスを利用することで、この検索処理を劇的に高速化できます。

## 2. なぜインデックスが必要か？

現代のアプリケーションは、日々膨大なデータを生成・蓄積します。EC サイトの商品リスト、SNS の投稿、企業の顧客情報など、その規模は数百万、数千万レコードに達することも珍しくありません。

こうした大規模なデータの中から、「特定の名前の顧客を探す」「ある価格帯の商品を一覧表示する」といった要求に応える際、もしインデックスがなければ、データベースはテーブルのすべての行を一つひとつ確認しなければなりません。これは、図書館で一冊の本を探すために、すべての本棚を端から端まで見て回るようなものです。非常に非効率で、ユーザーを待たせる原因となります。

インデックスは、こうした非効率を解消し、優れたパフォーマンスを提供するために不可欠な技術です。

## 3. インデックスの仕組み

インデックスは、それ自体がテーブルとは別のデータ構造としてデータベース内に保存されます。最も一般的に利用されるデータ構造が **B-tree（B 木）** です。

- **B-tree**:
  B-tree は、データが常にソート（整列）された状態に保たれる木構造の一種です。各ノード（木の枝分かれ部分）が複数の子ノードを持つことができ、データの検索、挿入、削除を効率的に行える（対数時間 `O(log n)`）という特徴があります。値がソートされているため、「`=`」による完全一致検索だけでなく、「`>`」や「`<`」を使った範囲検索も高速に処理できます。

インデックスを作成すると、データベースは指定されたカラムの値を B-tree 構造で保持します。各値には、実際のテーブル行へのポインタが紐付いています。検索クエリが実行されると、データベースはまずこの B-tree をたどって目的の値を探し、見つかったポインタを使ってテーブル本体から対応するデータを直接取得します。これにより、フルテーブルスキャンを回避し、高速なデータアクセスが実現します。

## 4. インデックスの主な種類

インデックスにはいくつかの種類があり、用途に応じて使い分けられます。

- **クラスタ化インデックス (Clustered Index)**:
  テーブルの物理的なデータの並び順そのものを、インデックスのキーの順序と一致させるインデックスです。本で言えば、ページ番号順に並んでいる状態そのものです。そのため、**1 つのテーブルに 1 つしか作成できません**。データの物理的な配置を決めてしまうため、範囲検索などで特に高いパフォーマンスを発揮します。通常、主キー（Primary Key）に自動的に設定されます。

- **非クラスタ化インデックス (Non-Clustered Index)**:
  テーブルの物理的な順序とは独立して作成されるインデックスです。本の巻末の索引はこちらのイメージに近いです。データ本体とは別の場所に索引データが作られ、そこからページ番号（ポインタ）を引いて本体を探しにいきます。**1 つのテーブルに複数作成できます**。

- **複合インデックス (Composite Index)**:
  複数のカラムを組み合わせて 1 つのインデックスを作成するものです。例えば、「姓」と「名」の両方で検索することが多い場合、これら 2 つのカラムで複合インデックスを作成すると、クエリのパフォーマンスが向上します。

## 5. 利点と注意点（トレードオフ）

インデックスは強力なツールですが、銀の弾丸ではありません。利点と注意点を理解することが重要です。

- **利点**:

  - `SELECT` クエリ、特に `WHERE` 句や `JOIN` 句を使った検索処理が大幅に高速化される。

- **注意点（トレードオフ）**:
  - **書き込み性能の低下**: データの `INSERT`（追加）、`UPDATE`（更新）、`DELETE`（削除）が行われるたびに、インデックスも更新する必要があります。そのため、インデックスが多いテーブルほど、これらの書き込み処理の速度は低下します。
  - **ストレージ容量の消費**: インデックスはテーブル本体とは別にデータを保持するため、追加のディスク容量を必要とします。

## 6. どのような時にインデックスを使うか？

上記のトレードオフを踏まえ、インデックスは以下のような場合に特に有効です。

- **`WHERE`句の条件として頻繁に使用されるカラム**: `user_id` や `product_code` など、検索の絞り込みでよく使われるカラム。
- **`JOIN`句の結合条件に使用されるカラム**: テーブル同士を結合する際のキーとなるカラム（外部キーなど）。
- **カーディナリティ（値の種類の多さ）が高いカラム**: ユーザー ID やメールアドレスのように、ほとんどの値がユニークであるカラムはインデックスの効果が高いです。
- **逆に、カーディナリティが低いカラム**（例：「性別」のように数種類しか値がないカラム）では、インデックスの効果が薄いか、場合によっては逆効果になることもあります。
- データの更新よりも検索の頻度が圧倒的に高いテーブルに向いています。
